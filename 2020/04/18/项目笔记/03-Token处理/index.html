<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="姑姑">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="测试顺带笔记" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        项目笔记/03-Token处理｜undefined
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2020/04/18/项目笔记/03-Token处理/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<style>

    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    测试顺带笔记
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>项目笔记/03-Token处理</h1>
                    
                    <span class="meta">
                         作者 摸鱼侠
                        <span>
                          日期 2020-04-18
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            项目笔记/03-Token处理
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="三、Token-处理"><a href="#三、Token-处理" class="headerlink" title="三、Token 处理"></a>三、Token 处理</h1><h2 id="Token-介绍"><a href="#Token-介绍" class="headerlink" title="Token 介绍"></a>Token 介绍</h2><h3 id="HTTP-是无状态的"><a href="#HTTP-是无状态的" class="headerlink" title="HTTP 是无状态的"></a>HTTP 是无状态的</h3><p><img src="/.com//v2-dde997503ed9d450e2f39042d53d4307_hd.png" alt="HTTP 是无状态的"></p>
<h3 id="基于-Cookie-的状态保持"><a href="#基于-Cookie-的状态保持" class="headerlink" title="基于 Cookie 的状态保持"></a>基于 Cookie 的状态保持</h3><p><img src="/.com//v2-85622297a93f493c891ffb90b67fd5e0_hd.png" alt="img"></p>
<p><img src="/.com//v2-1f49734871c5e2da2d264d28ac310a65_hd.png" alt="img"></p>
<p>Cookie 在客户端本地，用户可以操作它，所以不适合存储对安全性要求比较高的数据。</p>
<h3 id="基于-Session-的状态保持"><a href="#基于-Session-的状态保持" class="headerlink" title="基于 Session 的状态保持"></a>基于 Session 的状态保持</h3><img src="/.com//image-20200108192548559.png" alt="image-20200108192548559" style="zoom: 80%;">

<p>Session 不是新东西，它是基于 Cookie 的一个服务端技术，用一个生活中的例子来解释就好比我们逛超市存包。</p>
<ul>
<li>你：客户端</li>
<li>超市：服务器</li>
<li>存物柜：服务端的 Session Store<ul>
<li>存储用户的状态等对安全性比较高的数据</li>
</ul>
</li>
<li>你拿的那个凭据：访问服务端 Session 数据的凭证<ul>
<li>凭证是服务端给你的</li>
<li>凭证是唯一的</li>
</ul>
</li>
</ul>
<p>Session 其实就是把对安全性要求比较高的状态数据放到了服务端，把访问数据的钥匙放到了用户的本地（Cookie）。</p>
<p>用户的登录状态肯定是安全性要求比较高的，所以通常会使用 Session 来存储用户的登录状态。</p>
<p><img src="/.com//v2-0b02fa4a73a8072eb03cdf78270235e1_hd.png" alt="img"></p>
<p>1、用户向服务器发送用户名和密码。</p>
<p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>
<p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p>
<p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p>
<p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。</p>
<h3 id="基于-Token（令牌、凭据、凭证）-的状态保持"><a href="#基于-Token（令牌、凭据、凭证）-的状态保持" class="headerlink" title="基于 Token（令牌、凭据、凭证） 的状态保持"></a>基于 Token（令牌、凭据、凭证） 的状态保持</h3><p>基于 Token 的的思路是，服务器认证以后，生成一个加密数据（令牌），发回给用户，数据内容就像下面这样。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，用户与服务端通信的时候，都要发回这个加密数据（令牌）。服务器通过解密获取明文数据就知道了用户身份。</p>
<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<p>基于 <code>token</code> 的鉴权机制类似于 HTTP 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 <code>token</code> 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p><img src="/.com//ezgif-5-ae2b96ba00b5.png" alt></p>
<p>1、用户使用用户名密码来请求服务器</p>
<p>2、服务器进行验证用户的信息</p>
<p>3、服务器通过验证发送给用户一个 token</p>
<p>4、客户端存储 token，并在每次请求时附送上这个 token 值</p>
<p>5、服务端验证 token 值，并返回数据</p>
<p>以上就是基于 Token 认证的思路。</p>
<h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p>有了基于 Token 认证的思路了，该如何实现呢？例如</p>
<ul>
<li>如何生成 Token？</li>
<li>如何加密？</li>
<li>如何解密？</li>
<li>如何规定数据格式？</li>
</ul>
<p>如果大家都各自搞一套，太麻烦。所以社区中制定了一个具体实现：<a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Token</a>。</p>
<ul>
<li>Java</li>
<li>PHP</li>
<li>Ruby</li>
<li>Python</li>
<li>Node.js</li>
<li>。。。。</li>
</ul>
<p>该方案主要是对 JSON 格式数据进行加解密以及数据格式的规范，方便前后端交互。</p>
<p><img src="/.com//image-20200108012948915.png" alt="image-20200108012948915"></p>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p>JWT 的一些特点如下：</p>
<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<blockquote>
<p>扩展阅读</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li>
</ul>
</blockquote>
<h2 id="存储-Token"><a href="#存储-Token" class="headerlink" title="存储 Token"></a>存储 Token</h2><p><img src="/.com//image-20200109192157006.png" alt="image-20200109192157006"></p>
<p>我们项目中哪里需要使用呢？</p>
<ul>
<li>请求需要权限的接口</li>
<li>底部导航栏中也需要使用判断登录状态给出不同的提示<ul>
<li>已登录：我的</li>
<li>未登录：未登录</li>
</ul>
</li>
<li>我的页面也要使用，判断登录状态给出不同的页面展示</li>
<li>…</li>
</ul>
<p>往哪儿存？</p>
<ul>
<li>本地存储（持久化）<ul>
<li>获取麻烦</li>
<li>不是响应式</li>
</ul>
</li>
<li>Vuex 容器（推荐）<ul>
<li>获取方便</li>
<li>响应式的</li>
</ul>
</li>
</ul>
<p>思路：</p>
<ul>
<li>登录成功，将 token 存储到本地存储</li>
<li>为了持久化，还需要把 token 放到本地存储</li>
</ul>
<p>下面是具体实现。</p>
<p>一、使用 Vuex 容器存储 token</p>
<p>1、在 <code>src/store/index.js</code> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 登录用户，一个对象，包含 token 信息</span></span><br><span class="line">+    user: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">+    setUser (state, data) &#123;</span><br><span class="line">+      state.user = data</span><br><span class="line">+    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2、登录成功以后将后端返回的 token 相关数据存储到容器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> onLogin () &#123;</span><br><span class="line">  <span class="comment">// const loginToast = this.$toast.loading(&#123;</span></span><br><span class="line">  <span class="keyword">this</span>.$toast.loading(&#123;</span><br><span class="line">    duration: <span class="number">0</span>, <span class="comment">// 持续时间，0表示持续展示不停止</span></span><br><span class="line">    forbidClick: <span class="literal">true</span>, <span class="comment">// 是否禁止背景点击</span></span><br><span class="line">    message: <span class="string">'登录中...'</span> <span class="comment">// 提示消息</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> login(<span class="keyword">this</span>.user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.data.data =&gt; &#123; token: 'xxx', refresh_token: 'xxx' &#125;</span></span><br><span class="line">+    <span class="keyword">this</span>.$store.commit(<span class="string">'setUser'</span>, res.data.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示 success 或者 fail 的时候，会先把其它的 toast 先清除</span></span><br><span class="line">    <span class="keyword">this</span>.$toast.success(<span class="string">'登录成功'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'登录失败'</span>, err)</span><br><span class="line">    <span class="keyword">this</span>.$toast.fail(<span class="string">'登录失败，手机号或验证码错误'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止 loading，它会把当前页面中所有的 toast 都给清除</span></span><br><span class="line">  <span class="comment">// loginToast.clear()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完了，在浏览器中点击登录，通过 VueDevTools 查看数据是否能正常的存储到 Vuex 容器中。</p>
<p>二、持久化 token 存储</p>
<p>Vuex 容器中的数据只是为了方便在其他任何地方能获取登录状态数据，但是页面刷新还是会丢失数据状态，所以我们还要把数据进行持久化中以防止页面刷新丢失状态的问题。</p>
<p>前端持久化常见的方式就是：</p>
<ul>
<li>本地存储</li>
<li>Cookie</li>
</ul>
<p>这里我们以使用本地存储持久化用户状态为例。</p>
<p>为了方便，这里先封装一个用于操作本地存储的工具模块。</p>
<p>1、创建 <code>src/utils/storage.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装操作本地存储的工具方法模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getItem = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="built_in">window</span>.localStorage.getItem(name)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'转换失败'</span>, err)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setItem = <span class="function">(<span class="params">name, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">typeof</span> value === <span class="string">'object'</span></span><br><span class="line">    ? <span class="built_in">JSON</span>.stringify(value)</span><br><span class="line">    : value</span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(name, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeItem = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.localStorage.removeItem(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、然后在容器中使用使用本地存储持久化 token 数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">+ <span class="keyword">import</span> &#123; setItem, getItem &#125; <span class="keyword">from</span> <span class="string">'@/utils/storage'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 登录用户，一个对象，包含 token 信息</span></span><br><span class="line">+    user: getItem(<span class="string">'user'</span>)</span><br><span class="line">    <span class="comment">// user: null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setUser (state, data) &#123;</span><br><span class="line">      state.user = data</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了防止刷新丢失 state 中的 user 状态，我们把它放到本地存储</span></span><br><span class="line">+      setItem(<span class="string">'user'</span>, state.user)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>测试：重新登录，查看本地存储是否有 token 数据，刷新浏览器，查看 Vuex 容器是否有 token 数据。</p>
<p>经过以上处理之后，接下来我们项目中所有需要使用 token 的业务，直接找 Vuex 容器拿，不需要关心数据从哪儿来的。</p>
<h2 id="解析-Token"><a href="#解析-Token" class="headerlink" title="解析 Token"></a>解析 Token</h2><p>有时候我们需要使用到登录用户的相关信息，例如用户 ID，正常的话建议由后端返回，但是如果后端没有提供的话，我们也可以通过解析 JWT token 来获取。</p>
<blockquote>
<p>提示：token 中一定有表示用户身份的信息，例如 ID。</p>
</blockquote>
<p>这里主要使用到一个第三方工具包：<a href="https://github.com/auth0/jwt-decode" target="_blank" rel="noopener">jwt-decode</a>。</p>
<p>1、安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jwt-decode</span><br></pre></td></tr></table></figure>

<p>2、然后在容器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decodeJwt <span class="keyword">from</span> <span class="string">'jwt-decode'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setUser (state, data) &#123;</span><br><span class="line">  <span class="comment">// 解析 JWT 中的数据（需要使用用户ID）</span></span><br><span class="line">  <span class="keyword">if</span> (data &amp;&amp; data.token) &#123;</span><br><span class="line">    data.id = decodeJwt(data.token).user_id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state.user = data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了防止刷新丢失 state 中的 user 状态，我们把它放到本地存储</span></span><br><span class="line">  setItem(<span class="string">'user'</span>, state.user)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>之后就可以直接通过 <code>store.state.user.id</code> 来访问使用了。</p>
<h2 id="发送-Token"><a href="#发送-Token" class="headerlink" title="发送 Token"></a>发送 Token</h2><p>很多接口都需要提供 token（用户的登录状态） 才能访问。</p>
<p>方式一：在每次请求的时候手动添加（麻烦）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">""</span>,</span><br><span class="line">  url: <span class="string">""</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    token数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方式二：使用请求拦截器统一添加（推荐，更方便）</p>
<p>在 <code>src/utils/request.js</code> 中添加拦截器统一设置 token：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">request.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// config 请求配置对象，我们可以通过修改 config 来实现统一请求数据处理</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = store.state</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统一添加 token</span></span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="comment">// config.headers 获取操作请求头对象</span></span><br><span class="line">    <span class="comment">// Authorization 是后端要求的字段名称</span></span><br><span class="line">    <span class="comment">// 数据值后端要求提供：Bearer token数据</span></span><br><span class="line">    <span class="comment">//    注意：Bearer 后面有个空格</span></span><br><span class="line">    <span class="comment">// 老师，为啥？后端要求的</span></span><br><span class="line">    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;user.token&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with request error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="处理-Token-过期（在功能优化中进行讲解）"><a href="#处理-Token-过期（在功能优化中进行讲解）" class="headerlink" title="处理 Token 过期（在功能优化中进行讲解）"></a>处理 Token 过期（在功能优化中进行讲解）</h2><ul>
<li>为什么 token 过期时间这么短？<ul>
<li>为了安全</li>
</ul>
</li>
<li>过期了怎么办？<ul>
<li>通过登录页面重新登录获取 token</li>
<li>使用 refresh_token 重新获取新的 token</li>
</ul>
</li>
</ul>
<img src="/.com//1567481874811.png" alt="1567481874811" style="zoom: 50%;">

<p>在请求的响应拦截器中统一处理 token 过期：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装 axios 请求模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">import</span> jsonBig <span class="keyword">from</span> <span class="string">"json-bigint"</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"@/store"</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"@/router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios.create 方法：复制一个 axios</span></span><br><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">"http://ttapi.research.itcast.cn/"</span> <span class="comment">// 基础路径</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置处理后端返回数据中超出 js 安全整数范围问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">request.defaults.transformResponse = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> jsonBig.parse(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">request.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = store.state.user;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;user.token&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do something before request is sent</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with request error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">request.interceptors.response.use(</span><br><span class="line">  <span class="comment">// 响应成功进入第1个函数</span></span><br><span class="line">  <span class="comment">// 该函数的参数是响应对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Any status code that lie within the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response data</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 响应失败进入第2个函数，该函数的参数是错误对象</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response error</span></span><br><span class="line">    <span class="comment">// 如果响应码是 401 ，则请求获取新的 token</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应拦截器中的 error 就是那个响应的错误对象</span></span><br><span class="line">    <span class="built_in">console</span>.dir(error);</span><br><span class="line">    <span class="keyword">if</span> (error.response &amp;&amp; error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 校验是否有 refresh_token</span></span><br><span class="line">      <span class="keyword">const</span> user = store.state.user;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!user || !user.refresh_token) &#123;</span><br><span class="line">        router.push(<span class="string">"/login"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码不要往后执行了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有refresh_token，则请求获取新的 token</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">          method: <span class="string">"PUT"</span>,</span><br><span class="line">          url: <span class="string">"http://ttapi.research.itcast.cn/app/v1_0/authorizations"</span>,</span><br><span class="line">          headers: &#123;</span><br><span class="line">            Authorization: <span class="string">`Bearer <span class="subst">$&#123;user.refresh_token&#125;</span>`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获取成功，则把新的 token 更新到容器中</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"刷新 token  成功"</span>, res);</span><br><span class="line">        store.commit(<span class="string">"setUser"</span>, &#123;</span><br><span class="line">          token: res.data.data.token, <span class="comment">// 最新获取的可用 token</span></span><br><span class="line">          refresh_token: user.refresh_token <span class="comment">// 还是原来的 refresh_token</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把之前失败的用户请求继续发出去</span></span><br><span class="line">        <span class="comment">// config 是一个对象，其中包含本次失败请求相关的那些配置信息，例如 url、method 都有</span></span><br><span class="line">        <span class="comment">// return 把 request 的请求结果继续返回给发请求的具体位置</span></span><br><span class="line">        <span class="keyword">return</span> request(error.config);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果获取失败，直接跳转 登录页</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求刷线 token 失败"</span>, err);</span><br><span class="line">        router.push(<span class="string">"/login"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p><a href="https://github.com/lipengzhou/topline-m-89/tree/03-token" target="_blank" rel="noopener">https://github.com/lipengzhou/topline-m-89/tree/03-token</a></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2020/04/18/项目笔记/04-个人中心/" data-toggle="tooltip" data-placement="top"
                           title="项目笔记/04-个人中心">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2020/04/18/项目笔记/02-用户登录注册/" data-toggle="tooltip" data-placement="top"
                           title="项目笔记/02-用户登录注册">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#三、Token-处理"><span class="toc-text">三、Token 处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Token-介绍"><span class="toc-text">Token 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-是无状态的"><span class="toc-text">HTTP 是无状态的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-Cookie-的状态保持"><span class="toc-text">基于 Cookie 的状态保持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-Session-的状态保持"><span class="toc-text">基于 Session 的状态保持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-Token（令牌、凭据、凭证）-的状态保持"><span class="toc-text">基于 Token（令牌、凭据、凭证） 的状态保持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT（JSON-Web-Token）"><span class="toc-text">JWT（JSON Web Token）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储-Token"><span class="toc-text">存储 Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析-Token"><span class="toc-text">解析 Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送-Token"><span class="toc-text">发送 Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理-Token-过期（在功能优化中进行讲解）"><span class="toc-text">处理 Token 过期（在功能优化中进行讲解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最终代码"><span class="toc-text">最终代码</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 测试顺带笔记 2020
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/" target="_blank" rel="noopener">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
